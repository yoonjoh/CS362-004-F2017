Bug-Reports/ Debugging:
	There were several significant bugs that were discovered in the code upon applying the various testing methods that I had developed. For instance, one bug that echoed a bug that was apparent in even my own code was within the “fullDeckCount” function; this bug was further connected to another bug within the “scoreFor” function: as I was conducting my unit test 4 the vast majority of the results came back that the test had failed. After closer examination, I realized that the bug was mainly due to one of the parameters, and also how that parameter was being used in the three loops of the function. That parameter is “int card,” and the issue is that it is being used within a conditional (i.e., “if(state->deck[player][i] == card) count++”). This statement makes it such that the function only increments the count value when it comes across the specified card parameter value. In other words, instead counting all the cards in the entire deck (from all three sources of deck, hand, and display), it instead only counts the total for one specific card. For instance, if someone wanted to count how many “adventurer” cards there were in the deck, this would be the function to use, however, for the purposes of our program, this is NOT what we want, and thus results in a bug. Furthermore, there are more significant implications for the “scoreFor” function, since that is the only function that utilizes the fullDeckCount function. The “scoreFor” function uses 0 as its “int card” parameter, or in other words, is only counting how many total curse cards there are in the deck. In order to debug this matter, “scoreFor” function would directly depend on the debugging of “fullDeckCount,” which would have to be updated by removing the condition statements (i.e., “if(state->deck[player][i] == card)), and thereby only leaveing the “count++” to increment the total count of the deck. This in turn, would debug the “scoreFor” function. 

	Aside from the two bugs of the “fullDeckCount” and “scoreFor” functions, there was another noticeable bug within the refactored “smithy” card. My random test 1 (as it ran 1000 times) returned that none of the code runs were successful, which led me to reexamine the specific function in question, and discovered that the subtle bug that my teammate had intentionally introduced was that in the loop to gain more cards, instead of the conditional statement of what should be “i < 3” was instead “i <= 3”. In other words, there were 4 cards being gained by the user instead of just 3. As such, I was able to debug the situation by readjusting my random test 1 code so that the assertion would compare the pre-hand count + 4 to equal the post-hand count. After this update within my test code, the success rate was 100%. Another option to debug this issue would have been to alter the “smithy function within the dominion code itself by getting rid of the equal to sign in the “i <= 3”.  

	A final minor bug that I discovered upon running the overall programs through makefile and gcov was an innocent but particularly noticeable bug, in that the final “unittestresults.out” file, there were thousands of lines that said “card: ” followed by an integer that represented the enum of an action card. After reviewing my own unit test and random test codes to see where I had typed such a print command, I came to the realization that this was not due to code that I had created. Instead, after examining the “playCard” function of my teamate’s dominion code, I realized that she had written a print command probably for her personal testing purposes. After conferring with her regarding this bug, she confirmed my hypothesis that indeed, she had written the print code in order for testing and debugging during her own projects. Therefore, I debugged the problem by simply commenting out the extraneous print command, and this resulted in the expected “unittestresults.out” file outputs.
